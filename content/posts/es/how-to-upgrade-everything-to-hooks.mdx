---
title: 'React Hooks: La oportunidad de mejorar'
cover:
  {
    id: 'posts/how-to-upgrade-everything-to-hooks/banner',
    alt: 'React Hooks: La oportunidad de mejorar',
  }
published_at: '2019-08-09T00:00:00.000-04:00'
tags: ['Development', 'React', 'JavaScript', 'React Hooks']
seo:
  {
    title: 'React Hooks: La oportunidad de mejorar',
    description: 'Si todavÃ­a te estÃ¡s resistiendo a actualizar todo a hooks, no te preocupes - te explicarÃ© cÃ³mo usar efectivamente tanto useEffect como useState.',
  }
---

Es bien conocido que mientras mÃ¡s estemos escribiendo JavaScript plano sin hacer que Babel compile tantas cosas nuestro cÃ³digo estarÃ¡ mucho mÃ¡s optimizado y serÃ¡ mÃ¡s rÃ¡pido. Para esto llega React Hooks, disponible desde la versiÃ³n `>=16.8.0` reemplazando prÃ¡cticamente todo lo que habÃ­amos usado anteriormente con componentes de tipo clase, solo hay dos mÃ©todos que no han podido reemplazar los Hooks aÃºn: `componentDidCatch` y `getDerivedStateFromError` ğŸ˜”.

Normalmente nosotros hacemos un componente de tipo clase de esta manera:

```jsx
import React, { Component } from 'react';

class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0,
    };
  }

  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click me
        </button>
      </div>
    );
  }
}

export default Counter;
```

El cÃ³digo aparte de que se ve largo ğŸ˜’ hace que Babel transpile mÃ¡s cosas innecesarias, que el cÃ³digo se haga mÃ¡s largo y que pese mucho mÃ¡s nuestro JavaScript final. Para hacer que todos estos puntos mejoren llegaron los Hooks, haremos el mismo cÃ³digo pero usando el Hook de `useState()`:

```jsx
import React, { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

**Â¿MuchÃ­simo mÃ¡s condensado el cÃ³digo cierto ğŸ˜¨ğŸ˜±?** Aparte de esto estamos usando prÃ¡cticamente JavaScript plano esto hace que Babel no tenga que compilar aÃºn mÃ¡s cÃ³digo innecesario, Â¡e incluso podemos hacer el estado de nuestros inputs de los formularios con Hooks! ğŸ˜ğŸ’ª

Podemos hacerlo de la siguiente manera:

```jsx
import React, { useState } from 'react';

export default function ContactForm() {
  // Declaramos primero inputs el estado y setInputs la funciÃ³n, y lo igualamos a un objeto
  const [inputs, setInputs] = useState({});

  const handleChange = (e) => {
    // Con esto accederemos a las propiedades del evento de forma asÃ­ncrona
    e.persist();
    // Ahora llamamos a la funciÃ³n, le pasamos el estado actual y le pasamos tambiÃ©n el nombre del campo y su valor. Lo guardarÃ¡ justamente como un objeto
    setInputs((inputs) => ({ ...inputs, [e.target.name]: e.target.value }));
  };

  return (
    <form>
      {/*...*/}
      <label htmlFor="name">Name</label>
      <input type="text" name="name" onChange={handleChange} />
      {/*...*/}
    </form>
  );
}
```

Gracias a esto podemos hacer que nuestras aplicaciones estÃ©n mÃ¡s actualizadas, mucho mÃ¡s rÃ¡pida para nuestros clientes y utilizando las Ãºltimas caracterÃ­sticas. Ahora, Â¿quÃ© pasa con `componentDidMount()` el cual usamos para mayormente obtener data? Ahora es mucho mÃ¡s fÃ¡cil:

```jsx
import React, { useEffect } from 'react';

export default function Home() {
  // Simplemente llamaremos a la funciÃ³n useEffect() y dentro podremos lo que necesitamos hacer cuando el componente cargue
  useEffect(() => {
    miFuncionQueHaceFecthDeData();
  }, []);
}
```

Â¡Listo eso es todo ğŸ˜! Â¿QuÃ© es el array que coloquÃ© al final? Eso sirve para decirle a ese `useEffect()` si depende de algÃºn estado para funcionar y tambiÃ©n si no se le coloca ese array aunque sea vacÃ­o entrarÃ¡ en un bucle infinito; asÃ­ asegura que se ejecute una vez y solo cuando se necesite.

**_Â¿Es recomendable actualizar todo a Hooks?_** Desde mi punto de vista, si, Â¿por quÃ©? Mientras menos cÃ³digo que tenga que compilar Babel serÃ¡ mucho mejor para tu negocio o aplicaciÃ³n. Â¿Lo mejor? Aprendes a usar mucho mejor JavaScript ğŸ’ª
